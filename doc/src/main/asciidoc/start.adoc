= Lightweight Java Visualizer
:imagesdir: images
:source-highlighter: highlightjs
:toc: left
:toclevels: 3
:apidocs: https://atp-mipt.github.io/ljv/apidocs/

== User Guide

=== What is LJV?

https://github.com/atp-mipt/ljv[LJV] is a tool for visualizing Java data structures, using Reflection API and http://graphviz.gitlab.io/[Graphviz].
Its original version was developed by https://www.gla.ac.uk/schools/computing/staff/?webapp=staffcontact&action=person&id=4cdcebe68a94[John Hamer] in 2004 and released under GNU GPL (see the https://www.cs.auckland.ac.nz/~j-hamer/LJV.html[original project page]).

This project aims to upgrade this tool to modern Java and make it an open source library in the modern sense of the word.

=== Getting started

The tool requires Java 11 or later version. You can use Maven or Gradle to import the https://search.maven.org/artifact/org.atp-fivt/ljv[LJV dependency]:

[source,xml]
----
<dependency>
  <groupId>org.atp-fivt</groupId>
  <artifactId>ljv</artifactId>
  <version>1.03</version>
</dependency>
----

Then use {apidocs}org/atpfivt/ljv/LJV.html#drawGraph(java.lang.Object)[`drawGraph`] method of {apidocs}org/atpfivt/ljv/LJV.html[`LJV`] class to get graphviz representation of any Java `Object`:
[source, java]
----
import org.atpfivt.ljv.LJV;

...

System.out.println(new LJV().drawGraph("Hello"));
----

The printed result will look like following:

[source, dot]
----
digraph Java {
    rankdir="TB";
    node[shape=plaintext]
    . . .
}
----

This is a graph definition in DOT graph description language. This script can be converted into a bitmap  or vector image using `dot` utility from `graphviz` package:

[source,bash]
----
dot -Tpng myfile.dot > myfile.png
----

Or, even simpler, the resulting script can be pasted to link:https://dreampuf.github.io/GraphvizOnline/[GraphViz Online] and visualized like this:

[graphviz]
----
digraph Java {
	rankdir="TB";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>String</td>
			</tr>
			<tr>
				<td>coder: 0</td>
			</tr>
			<tr>
				<td>hash: 0</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>72</td>
				<td>101</td>
				<td>108</td>
				<td>108</td>
				<td>111</td>
			</tr>
		</table>
	>];
	n1 -> n2[label="value",fontsize=12];
}
----

Or, even more simpler, you may use the following utility function in order to save some tedious copy-pasting:

[source,java]
----
public static void browse(LJV ljv, Object obj) {
    try {
        var dot = URLEncoder.encode(
              ljv.drawGraph(obj), "UTF8").replaceAll("\\+", "%20");
        Desktop.getDesktop().browse(
              new URI("https://dreampuf.github.io/GraphvizOnline/#" 
                      + dot));
    } catch (Exception e) {
        throw new IllegalStateException(e);
    }
}
----


The diagram can be interpreted as following:

* The `String` object that we are visualizing is represented as a 'root' node of the graph 
* This object has two fields of primitive types (`coder` and `hash`), with values set to zero.
* This object through the field `value` references another object of an array type. This array has 5 elements.
* Elements of the array are primitive values 72, 101, 108, 108 and 111.


=== Diagram customization

LJV has the ability to customize the view of the graph.

For example, you can specify any class to be treated as a  primitive type with {apidocs}org/atpfivt/ljv/LJV.html#setTreatAsPrimitive(java.lang.Class)[`setTreatAsPrimitive`] method. In this case, the result of `toString` call will be used as its value:
[source,java]
----
String graph = new LJV()
        .setTreatAsPrimitive(String.class)
        .drawGraph(
                new Object[]{new String[]{"a", "b", "c"}, new int[]{1, 2, 3}}
        );
----

[graphviz]
----
digraph Java {
	rankdir="TB";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0' cellpadding='9'>
			<tr>
				<td port="f0"></td>
				<td port="f1"></td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>a</td>
				<td>b</td>
				<td>c</td>
			</tr>
		</table>
	>];
	n1:f0 -> n2[label="0",fontsize=12];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>1</td>
				<td>2</td>
				<td>3</td>
			</tr>
		</table>
	>];
	n1:f1 -> n3[label="1",fontsize=12];
}

----

You can also change the drawing direction:
[source, java]
----
ArrayList<Object> a = new ArrayList<>();
        a.add(new Person("Albert", true, 35));
        a.add(new Person("Betty", false, 20));
        a.add(new java.awt.Point(100, -100));

String graph = new LJV()
        .setTreatAsPrimitive(String.class)
        .setDirection(Direction.LR)
        .drawGraph(a);
----

{apidocs}org/atpfivt/ljv/Direction.html[`Direction`] is an `enum` with four values that define the graph drawing direction (top to bottom, left to right, etc):

[graphviz]
----
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>ArrayList</td>
			</tr>
			<tr>
				<td>size: 3</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0' cellpadding='9'>
			<tr>
				<td port="f0"></td>
				<td port="f1"></td>
				<td port="f2"></td>
				<td port="f3"></td>
				<td port="f4"></td>
				<td port="f5"></td>
				<td port="f6"></td>
				<td port="f7"></td>
				<td port="f8"></td>
				<td port="f9"></td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Person</td>
			</tr>
			<tr>
				<td>name: Albert</td>
			</tr>
			<tr>
				<td>gender: MALE</td>
			</tr>
			<tr>
				<td>age: 35</td>
			</tr>
		</table>
	>];
	n2:f0 -> n3[label="0",fontsize=12];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Person</td>
			</tr>
			<tr>
				<td>name: Betty</td>
			</tr>
			<tr>
				<td>gender: FEMALE</td>
			</tr>
			<tr>
				<td>age: 20</td>
			</tr>
		</table>
	>];
	n2:f1 -> n4[label="1",fontsize=12];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Point</td>
			</tr>
			<tr>
				<td>x: 100</td>
			</tr>
			<tr>
				<td>y: -100</td>
			</tr>
		</table>
	>];
	n2:f2 -> n5[label="2",fontsize=12];
	n1 -> n2[label="elementData",fontsize=12];
}

----

It is also possible to set colors and styles for the components of the graph:
[source, java]
----
Node n1 = new Node("A");
n1.level = 1;
AnotherNode n2 = new AnotherNode("B");
n2.level = 2;
AnotherNode n3 = new AnotherNode("C");
n3.level = 2;

n1.left = n2;
n1.right = n3;
n1.right.left = n1;
n1.right.right = n1;

String graph = new LJV()
    .addFieldAttribute("left", "color=red,fontcolor=red")
    .addFieldAttribute("right", "color=blue,fontcolor=blue")
    .addClassAttribute(Node.class, "color=pink,style=filled")
    .addIgnoreField("level")
    .addIgnoreField("ok")
    .setTreatAsPrimitive(String.class)
    .setShowFieldNamesInLabels(false)
    .drawGraph(n1);
----

[graphviz]
----
digraph Java {
	rankdir="TB";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>A</td>
			</tr>
		</table>
	>,color=pink,style=filled];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>AnotherNode</td>
			</tr>
			<tr>
				<td>B</td>
			</tr>
			<tr>
				<td>null</td>
			</tr>
			<tr>
				<td>null</td>
			</tr>
		</table>
	>];
	n1 -> n2[label="left",fontsize=12,color=red,fontcolor=red];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>AnotherNode</td>
			</tr>
			<tr>
				<td>C</td>
			</tr>
		</table>
	>];
	n3 -> n1[label="left",fontsize=12,color=red,fontcolor=red];
	n3 -> n1[label="right",fontsize=12,color=blue,fontcolor=blue];
	n1 -> n3[label="right",fontsize=12,color=blue,fontcolor=blue];
}

----

== Usage 

=== java.util.String before and after Java 9

The most widely used type of data in Java is, of course, `String`.
Starting from Java 9, the internal representation of `String` has changed: `char[]` was replaced by `byte[]`, and `coder` flag was introduced in order to switch between 8-bit and 16-bit character representation. This allowed  significant memory optimization for strings that contain only LATIN-1 charset characters: 


[cols="33a,33a,33a"]
|===
|

[source,java]
----
/*Java 8-: one 16-bit char per character*/
new LJV().drawGraph("abcαβγ");
----

[graphviz]
--
digraph Java {
    rankdir="TB";
    node[shape=plaintext]
    n1[label=<
        <table border='0' cellborder='1' cellspacing='0'>
            <tr>
                <td colspan='1'>String</td>
                <td>hash: 0</td>
            </tr>
        </table>
    >];
    n2[label=<
        <table border='0' cellborder='1' cellspacing='0'>
            <tr>
                <td>a</td>
                <td>b</td>
                <td>c</td>
                <td>&alpha;</td>
                <td>&beta;</td>
                <td>&gamma;</td>
            </tr>
        </table>
    >];
    n1 -> n2[label="value",fontsize=12];
}
--
|

[source,java]
----
/*Java 9+: coder set to 0 and one byte per LATIN-1 character*/
new LJV().drawGraph("abc");
----

[graphviz]
----
digraph Java {
	rankdir="TB";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>String</td>
			</tr>
			<tr>
				<td>coder: 0</td>
			</tr>
			<tr>
				<td>hash: 0</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>97</td>
				<td>98</td>
				<td>99</td>
			</tr>
		</table>
	>];
	n1 -> n2[label="value",fontsize=12];
}
----




|

[source,java]
----
/*Java 9+: coder set to 1 
and 2 bytes per character 
if there are symbols outside 
LATIN-1 set*/
new LJV().drawGraph("abcαβγ");
----

[graphviz]
--
digraph Java {
	rankdir="TB";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>String</td>
			</tr>
			<tr>
				<td>coder: 1</td>
			</tr>
			<tr>
				<td>hash: 0</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>97</td>
				<td>0</td>
				<td>98</td>
				<td>0</td>
				<td>99</td>
				<td>0</td>
				<td>-79</td>
				<td>3</td>
				<td>-78</td>
				<td>3</td>
				<td>-77</td>
				<td>3</td>
			</tr>
		</table>
	>];
	n1 -> n2[label="value",fontsize=12];
}
--

|===

=== String creation

One rarely needs to create `String` using `new` operator, however it's worth noticing that `String(String original)` constructor reuses the internal byte array of its argument. 
Concatenation (even with an empty string!) always produces a full new copy:

[source,java]
--
String x = "Hello";
new LJV().drawGraph(new String[]{
    x, new String(x),
    new String(x.toCharArray()),
    x + ""});
--

[graphviz]
--
digraph Java {
	rankdir="TB";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0' cellpadding='9'>
			<tr>
				<td port="f0"></td>
				<td port="f1"></td>
				<td port="f2"></td>
				<td port="f3"></td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>String</td>
			</tr>
			<tr>
				<td>coder: 0</td>
			</tr>
			<tr>
				<td>hash: 0</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>72</td>
				<td>101</td>
				<td>108</td>
				<td>108</td>
				<td>111</td>
			</tr>
		</table>
	>];
	n2 -> n3[label="value",fontsize=12];
	n1:f0 -> n2[label="0",fontsize=12];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>String</td>
			</tr>
			<tr>
				<td>coder: 0</td>
			</tr>
			<tr>
				<td>hash: 0</td>
			</tr>
		</table>
	>];
	n4 -> n3[label="value",fontsize=12];
	n1:f1 -> n4[label="1",fontsize=12];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>String</td>
			</tr>
			<tr>
				<td>coder: 0</td>
			</tr>
			<tr>
				<td>hash: 0</td>
			</tr>
		</table>
	>];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>72</td>
				<td>101</td>
				<td>108</td>
				<td>108</td>
				<td>111</td>
			</tr>
		</table>
	>];
	n5 -> n6[label="value",fontsize=12];
	n1:f2 -> n5[label="2",fontsize=12];
	n7[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>String</td>
			</tr>
			<tr>
				<td>coder: 0</td>
			</tr>
			<tr>
				<td>hash: 0</td>
			</tr>
		</table>
	>];
	n8[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>72</td>
				<td>101</td>
				<td>108</td>
				<td>108</td>
				<td>111</td>
			</tr>
		</table>
	>];
	n7 -> n8[label="value",fontsize=12];
	n1:f3 -> n7[label="3",fontsize=12];
}

--

=== String interning

Calling `intern()` deduplicates all the `String` objects and reduce them to a single value kept in the `String` pool (compare with the previous example): 

[source,java]
----
String x = "Hello";
new LJV().drawGraph(new String[]{
  x, new String(x).intern(),
  new String(x.toCharArray()).intern(),
  (x + "").intern()}));
----

[graphviz]
----
digraph Java {
	rankdir="TB";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0' cellpadding='9'>
			<tr>
				<td port="f0"></td>
				<td port="f1"></td>
				<td port="f2"></td>
				<td port="f3"></td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>String</td>
			</tr>
			<tr>
				<td>coder: 0</td>
			</tr>
			<tr>
				<td>hash: 0</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>72</td>
				<td>101</td>
				<td>108</td>
				<td>108</td>
				<td>111</td>
			</tr>
		</table>
	>];
	n2 -> n3[label="value",fontsize=12];
	n1:f0 -> n2[label="0",fontsize=12];
	n1:f1 -> n2[label="1",fontsize=12];
	n1:f2 -> n2[label="2",fontsize=12];
	n1:f3 -> n2[label="3",fontsize=12];
}
----

=== Boxed primitives caching

Usually we create boxed primitives via autoboxing. In rare cases when we do need to create e. g. `Integer` object explicitly, the correct way to do this is with `Integer.valueOf` method. This method deduplicates values in the range from -128 to 127 or `-XX:AutoBoxCacheMax` value.

Values outside this range will not be deduplicated even when autoboxing is used.

`Integer` created with constructor will never be deduplicated, and this constructor is deprecated since Java 9.

[source,java]
----
new LJV().drawGraph(new Integer[]{
    42, Integer.valueOf(42),
    new Integer(42),
    -4242, -4242
});
----

[graphviz]
----
digraph Java {
	rankdir="TB";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0' cellpadding='9'>
			<tr>
				<td port="f0"></td>
				<td port="f1"></td>
				<td port="f2"></td>
				<td port="f3"></td>
				<td port="f4"></td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Integer</td>
			</tr>
			<tr>
				<td>value: 42</td>
			</tr>
		</table>
	>];
	n1:f0 -> n2[label="0",fontsize=12];
	n1:f1 -> n2[label="1",fontsize=12];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Integer</td>
			</tr>
			<tr>
				<td>value: 42</td>
			</tr>
		</table>
	>];
	n1:f2 -> n3[label="2",fontsize=12];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Integer</td>
			</tr>
			<tr>
				<td>value: -4242</td>
			</tr>
		</table>
	>];
	n1:f3 -> n4[label="3",fontsize=12];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Integer</td>
			</tr>
			<tr>
				<td>value: -4242</td>
			</tr>
		</table>
	>];
	n1:f4 -> n5[label="4",fontsize=12];
}
----

=== LinkedList

Linked list is a data structure with theoretical O(1) efficiency for adding/removing its random node that can acts both as `List` and `Deque`. In Java practice, however, `LinkedList` is superceded by `ArrayList` and `ArrayDeque` in all the cases, and it's https://twitter.com/joshbloch/status/583813919019573248[questionable] whether this class is needed in standard library at all.

[source, java]
----
List<Integer> list = new LinkedList<>(); 
list.add(1); list.add(42); list.add(21);

new LJV()
  .setTreatAsPrimitive(Integer.class)
  .setDirection(Direction.LR)
  .drawGraph(list);
----

[graphviz]
----
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>LinkedList</td>
			</tr>
			<tr>
				<td>size: 3</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Node</td>
			</tr>
			<tr>
				<td>item: 1</td>
			</tr>
			<tr>
				<td>prev: null</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Node</td>
			</tr>
			<tr>
				<td>item: 42</td>
			</tr>
		</table>
	>];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Node</td>
			</tr>
			<tr>
				<td>item: 21</td>
			</tr>
			<tr>
				<td>next: null</td>
			</tr>
		</table>
	>];
	n4 -> n3[label="prev",fontsize=12];
	n3 -> n4[label="next",fontsize=12];
	n3 -> n2[label="prev",fontsize=12];
	n2 -> n3[label="next",fontsize=12];
	n1 -> n2[label="first",fontsize=12];
	n1 -> n4[label="last",fontsize=12];
}

----


=== ArrayDeque

If not `LinkedList`, then what? Java has a number of high-performant array-based data structures. `ArrayList` is well-known, but there are also `ArrayDeque` based on looped array and `PriorityQueue` based on balanced binary heap, which is actually also an array.

Let's see, for example, how looped buffer of `ArrayDeque` works.

This structure implements queue  capabilities. If maximum number of elements in the queue does not grow over time, this data structure works very fast and memory efficient, with constant time for every operation.

[source,java]
----
LJV ljv = new LJV().setTreatAsPrimitive(Integer.class);

//note that this sets initial capacity to 5
Deque<Integer> arrayDeque = new ArrayDeque<>(4);
arrayDeque.add(1); arrayDeque.add(2); arrayDeque.add(3);

ljv.drawGraph(arrayDeque)
----

[graphviz]
----
digraph Java {
	rankdir="TB";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>ArrayDeque</td>
			</tr>
			<tr>
				<td>head: 0</td>
			</tr>
			<tr>
				<td>tail: 3</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>1</td>
				<td>2</td>
				<td>3</td>
				<td>null</td>
				<td>null</td>
			</tr>
		</table>
	>];
	n1 -> n2[label="elements",fontsize=12];
}

----

[source,java]
----
arrayDeque.poll(); //returns 1
arrayDeque.poll(); //returns 2

ljv.drawGraph(arrayDeque);
----

[graphviz]
----
digraph Java {
	rankdir="TB";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>ArrayDeque</td>
			</tr>
			<tr>
				<td>head: 2</td>
			</tr>
			<tr>
				<td>tail: 3</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>null</td>
				<td>null</td>
				<td>3</td>
				<td>null</td>
				<td>null</td>
			</tr>
		</table>
	>];
	n1 -> n2[label="elements",fontsize=12];
}

----

Here we reach the end of the buffer and start writing from the beginning:
[source,java]
----
arrayDeque.add(4); arrayDeque.add(5); arrayDeque.add(6);

ljv.drawGraph(arrayDeque);
----

[graphviz]
----
digraph Java {
	rankdir="TB";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>ArrayDeque</td>
			</tr>
			<tr>
				<td>head: 2</td>
			</tr>
			<tr>
				<td>tail: 1</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>6</td>
				<td>null</td>
				<td>3</td>
				<td>4</td>
				<td>5</td>
			</tr>
		</table>
	>];
	n1 -> n2[label="elements",fontsize=12];
}
----




=== HashMap

`HashMap` is a widely used data structure in Java. For many people, implementation  details of `HashMap` is also a favorite topic of discussion in a Java programmer job interview.

There are a number of ways to implement hash collisions resolution in a hash map, developers of Java platform chose linked lists:

[source,java]
----
Map<String, Integer> map = new HashMap<>();
map.put("one", 1);   map.put("two", 2);
map.put("three", 3); map.put("four", 4);

new LJV()
    .setTreatAsPrimitive(Integer.class)
    .setTreatAsPrimitive(String.class)
    .drawGraph(map);
----

[graphviz]
----
digraph Java {
	rankdir="TB";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='8'>HashMap</td>
			</tr>
			<tr>
				<td>threshold: 12</td>
			</tr>
			<tr>
				<td>keySet: null</td>
			</tr>
			<tr>
				<td>entrySet: null</td>
			</tr>
			<tr>
				<td>values: null</td>
			</tr>
			<tr>
				<td>modCount: 4</td>
			</tr>
			<tr>
				<td>size: 4</td>
			</tr>
			<tr>
				<td>loadFactor: 0.75</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0' cellpadding='9'>
			<tr>
				<td port="f0"></td>
				<td port="f1"></td>
				<td port="f2"></td>
				<td port="f3"></td>
				<td port="f4"></td>
				<td port="f5"></td>
				<td port="f6"></td>
				<td port="f7"></td>
				<td port="f8"></td>
				<td port="f9"></td>
				<td port="f10"></td>
				<td port="f11"></td>
				<td port="f12"></td>
				<td port="f13"></td>
				<td port="f14"></td>
				<td port="f15"></td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>Node</td>
			</tr>
			<tr>
				<td>hash: 3149078</td>
			</tr>
			<tr>
				<td>key: four</td>
			</tr>
			<tr>
				<td>value: 4</td>
			</tr>
			<tr>
				<td>next: null</td>
			</tr>
		</table>
	>];
	n2:f6 -> n3[label="6",fontsize=12];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>Node</td>
			</tr>
			<tr>
				<td>hash: 110183</td>
			</tr>
			<tr>
				<td>key: one</td>
			</tr>
			<tr>
				<td>value: 1</td>
			</tr>
			<tr>
				<td>next: null</td>
			</tr>
		</table>
	>];
	n2:f7 -> n4[label="7",fontsize=12];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Node</td>
			</tr>
			<tr>
				<td>hash: 115277</td>
			</tr>
			<tr>
				<td>key: two</td>
			</tr>
			<tr>
				<td>value: 2</td>
			</tr>
		</table>
	>];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>Node</td>
			</tr>
			<tr>
				<td>hash: 110338829</td>
			</tr>
			<tr>
				<td>key: three</td>
			</tr>
			<tr>
				<td>value: 3</td>
			</tr>
			<tr>
				<td>next: null</td>
			</tr>
		</table>
	>];
	n5 -> n6[label="next",fontsize=12];
	n2:f13 -> n5[label="13",fontsize=12];
	n1 -> n2[label="table",fontsize=12];
}

----

==== Collision

While the number of collisions on a single `HashMap` bucket is small, the linked list keeps growing:

[source,java]
----
List<String> collisionString = new HashCodeCollision().genCollisionString(3);
Map<String, Integer> map = new HashMap<>();

for (int i = 0; i < collisionString.size(); i++) {
    map.put(collisionString.get(i), i);
}

new LJV()
    .setDirection(Direction.LR)
    .setTreatAsPrimitive(Integer.class)
    .setTreatAsPrimitive(String.class)
    .setIgnoreNullValuedFields(true)
    .drawGraph(map);
----

[graphviz]
----
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>HashMap</td>
			</tr>
			<tr>
				<td>threshold: 12</td>
			</tr>
			<tr>
				<td>modCount: 3</td>
			</tr>
			<tr>
				<td>size: 3</td>
			</tr>
			<tr>
				<td>loadFactor: 0.75</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0' cellpadding='9'>
			<tr>
				<td port="f0"></td>
				<td port="f1"></td>
				<td port="f2"></td>
				<td port="f3"></td>
				<td port="f4"></td>
				<td port="f5"></td>
				<td port="f6"></td>
				<td port="f7"></td>
				<td port="f8"></td>
				<td port="f9"></td>
				<td port="f10"></td>
				<td port="f11"></td>
				<td port="f12"></td>
				<td port="f13"></td>
				<td port="f14"></td>
				<td port="f15"></td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Node</td>
			</tr>
			<tr>
				<td>hash: 96320</td>
			</tr>
			<tr>
				<td>key: aaa</td>
			</tr>
			<tr>
				<td>value: 0</td>
			</tr>
		</table>
	>];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Node</td>
			</tr>
			<tr>
				<td>hash: 96320</td>
			</tr>
			<tr>
				<td>key: abB</td>
			</tr>
			<tr>
				<td>value: 1</td>
			</tr>
		</table>
	>];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Node</td>
			</tr>
			<tr>
				<td>hash: 96320</td>
			</tr>
			<tr>
				<td>key: bBa</td>
			</tr>
			<tr>
				<td>value: 2</td>
			</tr>
		</table>
	>];
	n4 -> n5[label="next",fontsize=12];
	n3 -> n4[label="next",fontsize=12];
	n2:f0 -> n3[label="0",fontsize=12];
	n1 -> n2[label="table",fontsize=12];
}
----

==== 'Treeified' collision

However, if a single bucket becomes overloaded with collisions, and keys implement `Comparable` interface, the linked list turns to a tree.

This reduces the search time in a bucket from O(N) to O(log(N)) and mitigates a certain kind of DDoS attacks: 

[source, java]
----
List<String> collisionString = new HashCodeCollision().genCollisionString(6);
Map<String, Integer> map = new HashMap<>();

for (int i = 0; i < collisionString.size(); i++) {
    map.put(collisionString.get(i), i);
}

String graph = new LJV()
    .setTreatAsPrimitive(String.class)
    .setTreatAsPrimitive(Integer.class)
    .setIgnoreNullValuedFields(true)
    .drawGraph(map);
----

[graphviz]
----
digraph Java {
	rankdir="TB";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>HashMap</td>
			</tr>
			<tr>
				<td>threshold: 48</td>
			</tr>
			<tr>
				<td>modCount: 13</td>
			</tr>
			<tr>
				<td>size: 13</td>
			</tr>
			<tr>
				<td>loadFactor: 0.75</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0' cellpadding='9'>
			<tr>
				<td port="f0"></td>
				<td port="f1"></td>
				<td port="f2"></td>
				<td port="f3"></td>
				<td port="f4"></td>
				<td port="f5"></td>
				<td port="f6"></td>
				<td port="f7"></td>
				<td port="f8"></td>
				<td port="f9"></td>
				<td port="f10"></td>
				<td port="f11"></td>
				<td port="f12"></td>
				<td port="f13"></td>
				<td port="f14"></td>
				<td port="f15"></td>
				<td port="f16"></td>
				<td port="f17"></td>
				<td port="f18"></td>
				<td port="f19"></td>
				<td port="f20"></td>
				<td port="f21"></td>
				<td port="f22"></td>
				<td port="f23"></td>
				<td port="f24"></td>
				<td port="f25"></td>
				<td port="f26"></td>
				<td port="f27"></td>
				<td port="f28"></td>
				<td port="f29"></td>
				<td port="f30"></td>
				<td port="f31"></td>
				<td port="f32"></td>
				<td port="f33"></td>
				<td port="f34"></td>
				<td port="f35"></td>
				<td port="f36"></td>
				<td port="f37"></td>
				<td port="f38"></td>
				<td port="f39"></td>
				<td port="f40"></td>
				<td port="f41"></td>
				<td port="f42"></td>
				<td port="f43"></td>
				<td port="f44"></td>
				<td port="f45"></td>
				<td port="f46"></td>
				<td port="f47"></td>
				<td port="f48"></td>
				<td port="f49"></td>
				<td port="f50"></td>
				<td port="f51"></td>
				<td port="f52"></td>
				<td port="f53"></td>
				<td port="f54"></td>
				<td port="f55"></td>
				<td port="f56"></td>
				<td port="f57"></td>
				<td port="f58"></td>
				<td port="f59"></td>
				<td port="f60"></td>
				<td port="f61"></td>
				<td port="f62"></td>
				<td port="f63"></td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>TreeNode</td>
			</tr>
			<tr>
				<td>hash: -1426368933</td>
			</tr>
			<tr>
				<td>key: aaBBAa</td>
			</tr>
			<tr>
				<td>value: 3</td>
			</tr>
			<tr>
				<td>red: false</td>
			</tr>
		</table>
	>];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>TreeNode</td>
			</tr>
			<tr>
				<td>hash: -1426368933</td>
			</tr>
			<tr>
				<td>key: bAaBBB</td>
			</tr>
			<tr>
				<td>value: 7</td>
			</tr>
			<tr>
				<td>red: false</td>
			</tr>
		</table>
	>];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>TreeNode</td>
			</tr>
			<tr>
				<td>hash: -1426368933</td>
			</tr>
			<tr>
				<td>key: bBAaBB</td>
			</tr>
			<tr>
				<td>value: 9</td>
			</tr>
			<tr>
				<td>red: true</td>
			</tr>
		</table>
	>];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>TreeNode</td>
			</tr>
			<tr>
				<td>hash: -1426368933</td>
			</tr>
			<tr>
				<td>key: bBBBAa</td>
			</tr>
			<tr>
				<td>value: 11</td>
			</tr>
			<tr>
				<td>red: false</td>
			</tr>
		</table>
	>];
	n7[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>TreeNode</td>
			</tr>
			<tr>
				<td>hash: -1426368933</td>
			</tr>
			<tr>
				<td>key: bBBBBB</td>
			</tr>
			<tr>
				<td>value: 12</td>
			</tr>
			<tr>
				<td>red: true</td>
			</tr>
		</table>
	>];
	n7 -> n6[label="prev",fontsize=12];
	n7 -> n6[label="parent",fontsize=12];
	n6 -> n7[label="right",fontsize=12];
	n8[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>TreeNode</td>
			</tr>
			<tr>
				<td>hash: -1426368933</td>
			</tr>
			<tr>
				<td>key: bBBAaB</td>
			</tr>
			<tr>
				<td>value: 10</td>
			</tr>
			<tr>
				<td>red: true</td>
			</tr>
		</table>
	>];
	n8 -> n5[label="prev",fontsize=12];
	n8 -> n6[label="parent",fontsize=12];
	n8 -> n6[label="next",fontsize=12];
	n6 -> n8[label="prev",fontsize=12];
	n6 -> n8[label="left",fontsize=12];
	n6 -> n5[label="parent",fontsize=12];
	n6 -> n7[label="next",fontsize=12];
	n5 -> n6[label="right",fontsize=12];
	n9[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>TreeNode</td>
			</tr>
			<tr>
				<td>hash: -1426368933</td>
			</tr>
			<tr>
				<td>key: bBAaAa</td>
			</tr>
			<tr>
				<td>value: 8</td>
			</tr>
			<tr>
				<td>red: false</td>
			</tr>
		</table>
	>];
	n9 -> n4[label="prev",fontsize=12];
	n9 -> n5[label="parent",fontsize=12];
	n9 -> n5[label="next",fontsize=12];
	n5 -> n9[label="prev",fontsize=12];
	n5 -> n9[label="left",fontsize=12];
	n5 -> n4[label="parent",fontsize=12];
	n5 -> n8[label="next",fontsize=12];
	n4 -> n5[label="right",fontsize=12];
	n10[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>TreeNode</td>
			</tr>
			<tr>
				<td>hash: -1426368933</td>
			</tr>
			<tr>
				<td>key: bAaBAa</td>
			</tr>
			<tr>
				<td>value: 6</td>
			</tr>
			<tr>
				<td>red: false</td>
			</tr>
		</table>
	>];
	n11[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>TreeNode</td>
			</tr>
			<tr>
				<td>hash: -1426368933</td>
			</tr>
			<tr>
				<td>key: bAaAaB</td>
			</tr>
			<tr>
				<td>value: 5</td>
			</tr>
			<tr>
				<td>red: true</td>
			</tr>
		</table>
	>];
	n11 -> n10[label="right",fontsize=12];
	n12[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>TreeNode</td>
			</tr>
			<tr>
				<td>hash: -1426368933</td>
			</tr>
			<tr>
				<td>key: aaBBBB</td>
			</tr>
			<tr>
				<td>value: 4</td>
			</tr>
			<tr>
				<td>red: false</td>
			</tr>
		</table>
	>];
	n13[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>TreeNode</td>
			</tr>
			<tr>
				<td>hash: -1426368933</td>
			</tr>
			<tr>
				<td>key: aaBAaB</td>
			</tr>
			<tr>
				<td>value: 2</td>
			</tr>
			<tr>
				<td>red: false</td>
			</tr>
		</table>
	>];
	n14[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>TreeNode</td>
			</tr>
			<tr>
				<td>hash: -1426368933</td>
			</tr>
			<tr>
				<td>key: aaAaBB</td>
			</tr>
			<tr>
				<td>value: 1</td>
			</tr>
			<tr>
				<td>red: false</td>
			</tr>
		</table>
	>];
	n14 -> n13[label="right",fontsize=12];
	n15[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='5'>TreeNode</td>
			</tr>
			<tr>
				<td>hash: -1426368933</td>
			</tr>
			<tr>
				<td>key: aaAaAa</td>
			</tr>
			<tr>
				<td>value: 0</td>
			</tr>
			<tr>
				<td>red: false</td>
			</tr>
		</table>
	>];
	n15 -> n3[label="prev",fontsize=12];
	n15 -> n14[label="parent",fontsize=12];
	n15 -> n14[label="next",fontsize=12];
	n14 -> n15[label="prev",fontsize=12];
	n14 -> n15[label="left",fontsize=12];
	n14 -> n3[label="parent",fontsize=12];
	n14 -> n13[label="next",fontsize=12];
	n13 -> n14[label="prev",fontsize=12];
	n13 -> n14[label="parent",fontsize=12];
	n13 -> n12[label="next",fontsize=12];
	n12 -> n13[label="prev",fontsize=12];
	n12 -> n11[label="parent",fontsize=12];
	n12 -> n11[label="next",fontsize=12];
	n11 -> n12[label="prev",fontsize=12];
	n11 -> n12[label="left",fontsize=12];
	n11 -> n4[label="parent",fontsize=12];
	n11 -> n10[label="next",fontsize=12];
	n10 -> n11[label="prev",fontsize=12];
	n10 -> n11[label="parent",fontsize=12];
	n10 -> n4[label="next",fontsize=12];
	n4 -> n10[label="prev",fontsize=12];
	n4 -> n11[label="left",fontsize=12];
	n4 -> n3[label="parent",fontsize=12];
	n4 -> n9[label="next",fontsize=12];
	n3 -> n4[label="right",fontsize=12];
	n3 -> n14[label="left",fontsize=12];
	n3 -> n15[label="next",fontsize=12];
	n2:f27 -> n3[label="27",fontsize=12];
	n1 -> n2[label="table",fontsize=12];
}
----

=== LinkedHashMap

One of the features of `HashMap` is that this data structure completely 'forgets' the order of insertion of its elements. 
Also, iteration over `HashMap` is not very effective from performance point of view.
When insertion order matters, we can use `LinkedHashMap`, which is actually a `HashMap` combined with linked list. 
One of the possible use cases for `LinkedHashMap` is LRU cache implementation.

[source,java]
----
Map<String, Integer> map = new HashMap<>();
map.put("one", 1);   map.put("two", 2);
map.put("three", 3); map.put("four", 4);

new LJV().setDirection(LR)
    .setTreatAsPrimitive(Integer.class)
    .setTreatAsPrimitive(String.class)
    .drawGraph(map);
----

[graphviz]
----
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='6'>LinkedHashMap</td>
			</tr>
			<tr>
				<td>threshold: 12</td>
			</tr>
			<tr>
				<td>accessOrder: false</td>
			</tr>
			<tr>
				<td>modCount: 4</td>
			</tr>
			<tr>
				<td>size: 4</td>
			</tr>
			<tr>
				<td>loadFactor: 0.75</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Entry</td>
			</tr>
			<tr>
				<td>hash: 110183</td>
			</tr>
			<tr>
				<td>key: one</td>
			</tr>
			<tr>
				<td>value: 1</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Entry</td>
			</tr>
			<tr>
				<td>hash: 115277</td>
			</tr>
			<tr>
				<td>key: two</td>
			</tr>
			<tr>
				<td>value: 2</td>
			</tr>
		</table>
	>];
	n3 -> n2[label="before",fontsize=12];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Entry</td>
			</tr>
			<tr>
				<td>hash: 110338829</td>
			</tr>
			<tr>
				<td>key: three</td>
			</tr>
			<tr>
				<td>value: 3</td>
			</tr>
		</table>
	>];
	n4 -> n3[label="before",fontsize=12];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Entry</td>
			</tr>
			<tr>
				<td>hash: 3149078</td>
			</tr>
			<tr>
				<td>key: four</td>
			</tr>
			<tr>
				<td>value: 4</td>
			</tr>
		</table>
	>];
	n5 -> n4[label="before",fontsize=12];
	n4 -> n5[label="after",fontsize=12];
	n3 -> n4[label="after",fontsize=12];
	n3 -> n4[label="next",fontsize=12];
	n2 -> n3[label="after",fontsize=12];
	n1 -> n2[label="head",fontsize=12];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0' cellpadding='9'>
			<tr>
				<td port="f0"></td>
				<td port="f1"></td>
				<td port="f2"></td>
				<td port="f3"></td>
				<td port="f4"></td>
				<td port="f5"></td>
				<td port="f6"></td>
				<td port="f7"></td>
				<td port="f8"></td>
				<td port="f9"></td>
				<td port="f10"></td>
				<td port="f11"></td>
				<td port="f12"></td>
				<td port="f13"></td>
				<td port="f14"></td>
				<td port="f15"></td>
			</tr>
		</table>
	>];
	n6:f6 -> n5[label="6",fontsize=12];
	n6:f7 -> n2[label="7",fontsize=12];
	n6:f13 -> n3[label="13",fontsize=12];
	n1 -> n6[label="table",fontsize=12];
	n1 -> n5[label="tail",fontsize=12];
}

----

=== TreeMap

`TreeMap` in Java is a Red-Black tree that implements `NavigableMap`. This implementation provides guaranteed O(log(N)) time cost for get/put/remove operations, which in practice is inferior to `HashMap`.

We use `TreeMap` when we need `lowerKey(..)`, `higherKey(..)` and other `NavigableMap` capabilities not provided by a simple `Map`.

[source, java]
----
Map<String, Integer> map = new TreeMap<>();
map.put("one", 1);         map.put("two", 2);
map.put("three", 3);       map.put("four", 4);
new LJV().setDirection(LR)
    .setTreatAsPrimitive(Integer.class)
    .setTreatAsPrimitive(String.class)
    .setIgnoreNullValuedFields(true)
    .drawGraph(map);
----

[graphviz]
----
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>TreeMap</td>
			</tr>
			<tr>
				<td>size: 4</td>
			</tr>
			<tr>
				<td>modCount: 4</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Entry</td>
			</tr>
			<tr>
				<td>key: three</td>
			</tr>
			<tr>
				<td>value: 3</td>
			</tr>
			<tr>
				<td>color: true</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Entry</td>
			</tr>
			<tr>
				<td>key: two</td>
			</tr>
			<tr>
				<td>value: 2</td>
			</tr>
			<tr>
				<td>color: true</td>
			</tr>
		</table>
	>];
	n3 -> n2[label="parent",fontsize=12];
	n2 -> n3[label="right",fontsize=12];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Entry</td>
			</tr>
			<tr>
				<td>key: one</td>
			</tr>
			<tr>
				<td>value: 1</td>
			</tr>
			<tr>
				<td>color: true</td>
			</tr>
		</table>
	>];
	n4 -> n2[label="parent",fontsize=12];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Entry</td>
			</tr>
			<tr>
				<td>key: four</td>
			</tr>
			<tr>
				<td>value: 4</td>
			</tr>
			<tr>
				<td>color: false</td>
			</tr>
		</table>
	>];
	n5 -> n4[label="parent",fontsize=12];
	n4 -> n5[label="left",fontsize=12];
	n2 -> n4[label="left",fontsize=12];
	n1 -> n2[label="root",fontsize=12];
}

----

=== ConcurrentSkipListMap

`ConcurrentSkipListMap` is a thread-safe `NavigableMap` implementation, that uses quite a complex non-blocking algorithm involving random numbers generator. That's why for a given input its internal representation never looks the same from one run to another: 

[source, java]
----
ConcurrentSkipListMap<String, Integer> map = new ConcurrentSkipListMap<>();

map.put("one", 1);
map.put("two", 2);
map.put("three", 3);
map.put("four", 4);

String actualGraph = new LJV()
        .setTreatAsPrimitive(Integer.class)
        .setTreatAsPrimitive(String.class)
        .drawGraph(map);
----

==== First run

[graphviz]
----
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='8'>ConcurrentSkipListMap</td>
			</tr>
			<tr>
				<td>comparator: null</td>
			</tr>
			<tr>
				<td>keySet: null</td>
			</tr>
			<tr>
				<td>keySet: null</td>
			</tr>
			<tr>
				<td>descendingMap: null</td>
			</tr>
			<tr>
				<td>values: null</td>
			</tr>
			<tr>
				<td>values: null</td>
			</tr>
			<tr>
				<td>entrySet: null</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td>Index</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Index</td>
			</tr>
			<tr>
				<td>down: null</td>
			</tr>
		</table>
	>];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Index</td>
			</tr>
			<tr>
				<td>down: null</td>
			</tr>
			<tr>
				<td>right: null</td>
			</tr>
		</table>
	>];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Node</td>
			</tr>
			<tr>
				<td>key: one</td>
			</tr>
			<tr>
				<td>val: 1</td>
			</tr>
		</table>
	>];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Node</td>
			</tr>
			<tr>
				<td>key: three</td>
			</tr>
			<tr>
				<td>val: 3</td>
			</tr>
		</table>
	>];
	n7[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Node</td>
			</tr>
			<tr>
				<td>key: two</td>
			</tr>
			<tr>
				<td>val: 2</td>
			</tr>
			<tr>
				<td>next: null</td>
			</tr>
		</table>
	>];
	n6 -> n7[label="next",fontsize=12];
	n5 -> n6[label="next",fontsize=12];
	n4 -> n5[label="node",fontsize=12];
	n3 -> n4[label="right",fontsize=12];
	n8[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Node</td>
			</tr>
			<tr>
				<td>key: null</td>
			</tr>
			<tr>
				<td>val: null</td>
			</tr>
		</table>
	>];
	n9[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Node</td>
			</tr>
			<tr>
				<td>key: four</td>
			</tr>
			<tr>
				<td>val: 4</td>
			</tr>
		</table>
	>];
	n9 -> n5[label="next",fontsize=12];
	n8 -> n9[label="next",fontsize=12];
	n3 -> n8[label="node",fontsize=12];
	n2 -> n3[label="down",fontsize=12];
	n10[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='2'>Index</td>
			</tr>
			<tr>
				<td>right: null</td>
			</tr>
		</table>
	>];
	n10 -> n4[label="down",fontsize=12];
	n10 -> n5[label="node",fontsize=12];
	n2 -> n10[label="right",fontsize=12];
	n2 -> n8[label="node",fontsize=12];
	n1 -> n2[label="head",fontsize=12];
	n11[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>LongAdder</td>
			</tr>
			<tr>
				<td>base: 4</td>
			</tr>
			<tr>
				<td>cellsBusy: 0</td>
			</tr>
			<tr>
				<td>cells: null</td>
			</tr>
		</table>
	>];
	n1 -> n11[label="adder",fontsize=12];
}


----

==== Second run

[graphviz]
----
digraph Java {
	rankdir="LR";
	node[shape=plaintext]
	n1[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='8'>ConcurrentSkipListMap</td>
			</tr>
			<tr>
				<td>comparator: null</td>
			</tr>
			<tr>
				<td>keySet: null</td>
			</tr>
			<tr>
				<td>keySet: null</td>
			</tr>
			<tr>
				<td>descendingMap: null</td>
			</tr>
			<tr>
				<td>values: null</td>
			</tr>
			<tr>
				<td>values: null</td>
			</tr>
			<tr>
				<td>entrySet: null</td>
			</tr>
		</table>
	>];
	n2[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Index</td>
			</tr>
			<tr>
				<td>down: null</td>
			</tr>
			<tr>
				<td>right: null</td>
			</tr>
		</table>
	>];
	n3[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Node</td>
			</tr>
			<tr>
				<td>key: null</td>
			</tr>
			<tr>
				<td>val: null</td>
			</tr>
		</table>
	>];
	n4[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Node</td>
			</tr>
			<tr>
				<td>key: four</td>
			</tr>
			<tr>
				<td>val: 4</td>
			</tr>
		</table>
	>];
	n5[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Node</td>
			</tr>
			<tr>
				<td>key: one</td>
			</tr>
			<tr>
				<td>val: 1</td>
			</tr>
		</table>
	>];
	n6[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='3'>Node</td>
			</tr>
			<tr>
				<td>key: three</td>
			</tr>
			<tr>
				<td>val: 3</td>
			</tr>
		</table>
	>];
	n7[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>Node</td>
			</tr>
			<tr>
				<td>key: two</td>
			</tr>
			<tr>
				<td>val: 2</td>
			</tr>
			<tr>
				<td>next: null</td>
			</tr>
		</table>
	>];
	n6 -> n7[label="next",fontsize=12];
	n5 -> n6[label="next",fontsize=12];
	n4 -> n5[label="next",fontsize=12];
	n3 -> n4[label="next",fontsize=12];
	n2 -> n3[label="node",fontsize=12];
	n1 -> n2[label="head",fontsize=12];
	n8[label=<
		<table border='0' cellborder='1' cellspacing='0'>
			<tr>
				<td rowspan='4'>LongAdder</td>
			</tr>
			<tr>
				<td>base: 4</td>
			</tr>
			<tr>
				<td>cellsBusy: 0</td>
			</tr>
			<tr>
				<td>cells: null</td>
			</tr>
		</table>
	>];
	n1 -> n8[label="adder",fontsize=12];
}

----