= Lightweight Java Visualizer
:imagesdir: images


== Установка

Установка

== Начало

Простой пример с генерацией graphviz
[source, java]
----
String graph = new LJV().drawGraph("Hello");
----
В `graph` содержится сгенерированная graphviz-структура объекта, который мы передаем в `drawGraph()`
[source, graphviz]
----
digraph Java {
    rankdir="TB";
    node[shape=plaintext]
    n1[label=<
        <table border='0' cellborder='1' cellspacing='0'>
            <tr>
                <td colspan='2'>java.lang.String</td>
            </tr>
            <tr>
                <td>coder: 0</td>
                <td>hash: 0</td>
            </tr>
        </table>
    >];
    n2[label=<
        <table border='0' cellborder='1' cellspacing='0'>
            <tr>
                <td>72</td>
                <td>101</td>
                <td>108</td>
                <td>108</td>
                <td>111</td>
            </tr>
        </table>
    >];
    n1 -> n2[label="value",fontsize=12];
}
----
Полученную строку можно загрузить в link:https://dreampuf.github.io/GraphvizOnline/[онлайн-сервисы]
для GraphViz и построить вот такую визуализацию объекта:

image::stringIsNotAPrimitiveType.svg[]
== Кастомизация

LJV имеет возможность настраивать вид графа.

Например, можно строку указать как примитивный тип:
[source,java]
----
String graph = new LJV()
        .setTreatAsPrimitive(String.class)
        .drawGraph(
                new Object[]{new String[]{"a", "b", "c"}, new int[]{1, 2, 3}}
        );
----
image::arrwithprimitivestring.svg[]

Можно также перевернуть структуру:
[source, java]
----
ArrayList<Object> a = new ArrayList<>();
        a.add(new Person("Albert", true, 35));
        a.add(new Person("Betty", false, 20));
        a.add(new java.awt.Point(100, -100));

String graph = new LJV()
        .setTreatAsPrimitive(String.class)
        .setDirection(Direction.LR) # <1>
        .drawGraph(a);
----
<1> Direction - это enum с 4 типами:
* TB - по умолчанию, рисует сверху вниз
* BT - рисует снизу верх
* LR - рисует слева направо
* RL - рисует справа налево

image::lrwithperson.svg[]
== Интернирование строк

Библиотека

[source,java]
----
String x = "Hello";
String y = x;
String graph = new LJV().drawGraph(new Object[]{x, y});
----

image::stringwithoutduplicating.svg[]

[source,java]
----
String x = "Hello";
String y = new String(x);
String graph1 = new LJV().drawGraph(new Object[]{x, y});
String graph2 = new LJV().drawGraph(new Object[]{x, y.intern()});
----

image::stringwithduplicating.svg[]
image::stringwithintern.svg[]

== Кэширование wrapped objects

[source,java]
----
public class Example {
    private Integer i1 = 42;
    private Integer i2 = 42;
    private Integer i3 = 2020;
    private Integer i4 = 2020;
}
----

[source,java]
----
String graph = new LJV().drawGraph(new Example());
----

image::wrappedinteger.svg[]

== ArrayDeque

[source,java]
----
ArrayDeque<Integer> arrayDeque = new ArrayDeque<>();

String graph = new LJV().drawGraph(arrayDeque);
----

image::arraydeque1.svg[]

[source,java]
----
ArrayDeque<Integer> arrayDeque = new ArrayDeque<>();
arrayDeque.addLast(1);
arrayDeque.addLast(2);

String graph = new LJV()
        .setTreatAsPrimitive(Integer.class).drawGraph(arrayDeque);
----

image::arraydeque2.svg[]

[source,java]
----
ArrayDeque<Integer> arrayDeque = new ArrayDeque<>();
for (int i = 0; i < 20; i++) {
    arrayDeque.addLast(i);
}

String graph = new LJV()
        .setTreatAsPrimitive(Integer.class).drawGraph(arrayDeque);
----

image::arraydeque4.svg[]

[source,java]
----
ArrayDeque<Integer> arrayDeque = new ArrayDeque<>();
for (int i = 0; i < 20; i++) {
    arrayDeque.addLast(i);
}
for (int i = 0; i < 18; i++) {
    arrayDeque.removeFirst();
}

String graph = new LJV()
        .setTreatAsPrimitive(Integer.class).drawGraph(arrayDeque);
----

image::arraydeque3.svg[]

== LinkedList

[source, java]
----
LinkedList<Integer> linkedList = new LinkedList<>();
linkedList.add(1);
linkedList.add(42);
linkedList.add(21);

String graph = new LJV().drawGraph(linkedList);
----

image::linkedlist.svg[]

== HashMap

[source,java]
----
HashMap<String, Integer> map = new HashMap<>();
map.put("one", 1);
map.put("two", 2);
map.put("three", 3);
map.put("four", 4);

String graph = new LJV().drawGraph(map);
----

image::hashmap.svg[]

=== Collision...

[source,java]
----
List<String> collisionString = new HashCodeCollision().genCollisionString(6);
HashMap<String, Integer> map = new HashMap<>();

for (int i = 0; i < collisionString.size(); i++) {
    map.put(collisionString.get(i), i);
}

String graph = new LJV().drawGraph(map);
----

image::hashmap2.svg[]

=== Collision with 13 elements and tree map

image::hashmap3.svg[]

=== Hash collision for god of hash collision

image::hashmap4.svg[]

== LinkedHashMap

image::linkedhashmap.svg[]

== Treemap
[source, java]
----
TreeMap<String, Integer> map = new TreeMap<>();

map.put("one", 1);
map.put("two", 2);

String actualGraph = new LJV().drawGraph(map);
----

image::treemap.svg[]

== ConcurrentSkipListMap
[source, java]
----
ConcurrentSkipListMap<String, Integer> map = new ConcurrentSkipListMap<>();

map.put("one", 1);
map.put("two", 2);
map.put("three", 3);
map.put("four", 4);

String actualGraph = new LJV().drawGraph(map);
----

=== First start

image::skiplisttreemap.svg[]

=== Second start

image::skiplisttreemap2.svg[]