:revealjs_theme: white
//:revealjs_customtheme: white_course.css
// путник, пожалуйста, не добавляй это обратно, весь код поедет(
// меняй лучше slides.css по примеру из white_course.css
:revealjs_slideNumber:
:revealjs_history:
:revealjs_progress:
:encoding: UTF-8
:lang: ru
:doctype: article
:toclevels: 3
:imagesdir: images
:source-highlighter: highlightjs
:highlightjsdir: highlight
:icons: font
:iconfont-remote!:
:iconfont-name: font-awesome-4.7.0/css/font-awesome
:revealjs_mouseWheel: true
:revealjs_center: false
:revealjs_transition: none
:revealjs_width: 1600
:revealjs_height: 900
:stem: latexmath
:hardbreaks: true
:source-highlighter: highlightjs
:highlightjs-languages: java, kotlin, scala, groovy, graphviz
:customcss: slides.css

include::_doc_general_attributes.adoc[]

= The Lightweight Java Visualizer (LJV)

//== Часть 1. Введение
:!figure-caption:

== Кто мы

[cols="20a,80a"]
|===
.^| image::ponomarev.jpg[Иван,width=180]
.^|
Иван Пономарев:
- Software Engineer at KURS, tutor at MIPT

.^| image::selivanov.png[Илья,width=180]
.^|
Илья Селиванов:
- Студент МФТИ

.^| image::nogaev.png[Нурас,width=180]
.^|
Нурас Ногаев:
- Студент МФТИ
|===

== Идея

С помощью Reflection API в режиме runtime построить внутреннее представление графа объектов памяти.

[.stetch]
[graphviz]
----
include::code/hashmap_many_collissions.graphviz[]
----

[.notes]
--
reflection api На рисунке визуализирован хэшмап с огромной коллизией, и как он смог его переделать в тримап
--

== До нас

Инструмент был разработан Джоном Роэслером в 2004 году на java 1.4

[%hardbreaks]
[%hardbreaks]
[%hardbreaks]
https://www.cs.auckland.ac.nz/~j-hamer/ACE04-paper.pdf
Hamer, J.. “Visualising Java Data Structures as Graphs.” ACE (2004). /поправить/

// Спросить у Олега как правильно указать ссылку

== Проблемы

//[%step]
* Неудобство пользования
* Отсутствие поддержки инструмента
* Изменение графвиза
* Отсутствие ряда возможностей

[.notes]
--
1) Код теперь выглядит правильнее и удобнее 2) АПИ был старым и неудобным 3) Теперь каждый может легко получить доступ к инструменту и вносить вклад 4) теперь пакетные менеджеры могут легко скачать инструмент 5) Теперь используем новые фичи графвиза, html like labels
--

== Решения

//[%step]
* Обновление до Java 11
* Изменение API инструмента (method chaining)
* Выложили на github
* Выложили на maven central
* Полностью изменена генерация графа

[.notes]
--
1) Код теперь выглядит правильнее и удобнее 2) АПИ был старым и неудобным 3) Теперь каждый может легко получить доступ к инструменту и вносить вклад 4) теперь пакетные менеджеры могут легко скачать инструмент 5) Теперь используем новые фичи графвиза, html like labels.
Переписали генерацию
--

== Зачем он нужен

* Реверс инжиниринг кода
* Преподавание

[.notes]
--
1) Можно изучить строение любого(?) объекта в джаве 2) Благодаря визуальному отображению "внутренностей" кода, студентам будет проще понимать структуры данных
--

== Как использовать

[cols="a"]
|===
^|
[source,java]
----
String graph = new LJV().drawGraph("Hello");
----
^|
[graphviz]
----
include::code/string_java_8.graphviz[]
----
|===

[%notitle]
=== Hello graph

[.stretch]
[source,graphviz]
----
include::code/string_java_8.graphviz[]
----

== Настройки графа

Базовые типы Java можно представить в более удобном виде

[cols="a"]
|===
^|
[source,java]
----
String graph = new LJV()
        .setTreatAsPrimitive(String.class)
        .drawGraph(
                new Object[]{new String[]{"a", "b", "c"}, new int[]{1, 2, 3}}
        );
----
^|
[graphviz]
----
include::code/as_primitive.graphviz[]
----
|===

[%notitle]
=== Поворот

Есть возможность перевернуть структуру

[cols="a"]
|===
.^| [source,java]
----
ArrayList<Object> a = new ArrayList<>();
        a.add(new Person("Albert", true, 35));
        a.add(new Person("Betty", false, 20));
        a.add(new java.awt.Point(100, -100));

String graph = new LJV()
        .setTreatAsPrimitive(String.class)
        .setDirection(Direction.LR)
        .drawGraph(a);
----

^| [.column]
[graphviz]
----
include::code/arraylist_set_direction_lr.graphviz[]
----
|===

[%notitle]
=== Цвета

Можно разукрасить отдельные части графа

[cols="a"]
|===
^|
[source,java]
----
Node n1 = new Node("A");
...
n1.right.right = n1;

String graph = new LJV()
    .addFieldAttribute("left", "color=red,fontcolor=red")
    .addFieldAttribute("right", "color=blue,fontcolor=blue")
    .addClassAttribute(Node.class, "color=pink,style=filled")
    .addIgnoreField("level")
    .setTreatAsPrimitive(String.class)
    .setShowFieldNamesInLabels(false)
    .drawGraph(n1);
----
^|
[graphviz]
----
include::code/node_set_color.graphviz[]
----
|===

== String interning

[source,java]
----
String x = "Hello";
String y = x;
String graph = new LJV().drawGraph(new Object[]{x, y});
----

[graphviz]
----
include::code/string_interning_equate.graphviz[]
----

[%notitle]
=== Copy

[source,java]
----
String x = "Hello";
String y = new String(x);
String graph1 = new LJV().drawGraph(new Object[]{x, y});
----

[graphviz]
----
include::code/string_interning_new.graphviz[]
----

[%notitle]
=== Copy and intern

[source,java]
----
String x = "Hello";
String y = new String(x);
String graph2 = new LJV().drawGraph(new Object[]{x, y.intern()});
----

[graphviz]
----
include::code/string_interning_new_intern.graphviz[]
----

== Wrapped object caching

[source,java]
----
public class Example {
    private Integer i1 = 42;
    private Integer i2 = 42;
    private Integer i3 = 2020;
    private Integer i4 = 2020;
}
//...
String graph = new LJV().drawGraph(new Example());
----

[graphviz]
----
include::code/integer_caching.graphvize[]
----

== ArrayDeque

[source,java]
----
ArrayDeque<Integer> arrayDeque = new ArrayDeque<>();

String graph = new LJV().drawGraph(arrayDeque);
----

[graphviz]
----
include::code/arraydeque_empty.graphviz[]
----

=== Add few elemnts

[source,java]
----
ArrayDeque<Integer> arrayDeque = new ArrayDeque<>();
arrayDeque.addLast(1);
arrayDeque.addLast(2);

String graph = new LJV()
        .setTreatAsPrimitive(Integer.class)
        .drawGraph(arrayDeque);
----

[graphviz]
----
include::code/arraydeque_few_elements.graphviz[]
----

=== Add many elements

[source,java]
----
ArrayDeque<Integer> arrayDeque = new ArrayDeque<>();
for (int i = 0; i < 20; i++) {
    arrayDeque.addLast(i);
}

String graph = new LJV()
        .setTreatAsPrimitive(Integer.class)
        .drawGraph(arrayDeque);
----

[graphviz]
----
include::code/arraydeque_many_elements.graphviz[]
----

=== Add many and remove

[cols="a"]
|===
|
[source,java]
----
ArrayDeque<Integer> arrayDeque = new ArrayDeque<>();
for (int i = 0; i < 20; i++) {
    arrayDeque.addLast(i);
}
for (int i = 0; i < 18; i++) {
    arrayDeque.removeFirst();
}

String graph = new LJV()
        .setTreatAsPrimitive(Integer.class)
        .drawGraph(arrayDeque);
----

^|
[graphviz]
----
include::code/arraydeque_add_many_and_remove.graphviz[]
----
|===

== LinkedList

[cols="a"]
|===
^|
[source,java]
----
LinkedList<Integer> linkedList = new LinkedList<>();
linkedList.add(1);
linkedList.add(42);
linkedList.add(21);

String graph = new LJV()
        .setTreatAsPrimitive(Integer.class)
        .addFieldAttribute("next", "color=red,fontcolor=red")
        .addFieldAttribute("prev", "color=blue,fontcolor=blue")
        .addFieldAttribute("first", "color=red,fontcolor=red")
        .addFieldAttribute("last", "color=red,fontcolor=red")
        .drawGraph(linkedList);
----

^|
[graphviz]
----
include::code/linkedlist.graphviz[]
----
|===

== HashMap

[cols="a"]
|===
^|
[source,java]
----
HashMap<String, Integer> map = new HashMap<>();
map.put("one", 1);
map.put("two", 2);
map.put("three", 3);
map.put("four", 4);

String graph = new LJV()
        .setTreatAsPrimitive(Integer.class)
        .setTreatAsPrimitive(String.class)
        .drawGraph(map);
----

^|
[graphviz]
----
include::code/hashmap.graphviz[]
----
|===

=== Collision...

[cols="a"]
|===
^|
[source,java]
----
List<String> collisionString = new HashCodeCollision().genCollisionString(3);
HashMap<String, Integer> map = new HashMap<>();

for (int i = 0; i < collisionString.size(); i++) {
    map.put(collisionString.get(i), i);
}

String graph = new LJV()
        .setTreatAsPrimitive(Integer.class)
        .setTreatAsPrimitive(String.class)
        .drawGraph(map);
----

^|
[graphviz]
----
include::code/hashmap_3_collissions.graphviz[]
----
|===

=== Collision with 13 elements and tree map



[graphviz]
----
include::code/hashmap_13_collissions.graphviz[]
----

=== Hash collision for god of hash collision

[graphviz]
----
include::code/hashmap_many_collissions.graphviz[]
----

== Treemap

[cols="a"]
|===
|
[source,java]
----
TreeMap<String, Integer> map = new TreeMap<>();

map.put("one", 1);
map.put("two", 2);
map.put("three", 3);
map.put("four", 4);

String actualGraph = new LJV()
        .setTreatAsPrimitive(Integer.class)
        .setTreatAsPrimitive(String.class)
        .drawGraph(map);
----

^|
[graphviz]
----
include::code/treemap.graphviz[]
----
|===

== ConcurrentSkipListMap

[source,java]
----
ConcurrentSkipListMap<String, Integer> map = new ConcurrentSkipListMap<>();

map.put("one", 1);
map.put("two", 2);
map.put("three", 3);
map.put("four", 4);

String actualGraph = new LJV()
        .setTreatAsPrimitive(Integer.class)
        .setTreatAsPrimitive(String.class)
        .drawGraph(map);
----

=== First start

[graphviz]
----
include::code/concurrentskiplistmap_first_start.graphviz[]
----

=== Second start

[graphviz]
----
include::code/concurrentskiplistmap_second_start.graphviz[]
----